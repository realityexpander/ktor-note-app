import java.sql.Time
import java.text.SimpleDateFormat

buildscript {
    repositories {
        mavenCentral()
        //jcenter()
    }
    
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}

apply plugin: 'kotlin'
apply plugin: 'application'

group 'com.realityexpander'
version '0.1.1'
mainClassName = "io.ktor.server.netty.EngineMain"
def appName = 'ktor-note-app'

def appManifest = manifest().effectiveManifest
//        = {
//    attributes(
//            'Implementation-Title': $ { appName },
//            "Main-Class": mainClassName,
//            'Implementation-Version': $ { version },
//            'Implementation-Vendor': 'com.realityexpander',
//            'Implementation-Vendor-Id': 'com.realityexpander',
//            'Implementation-Vendor-Url': 'https://github.com/realityexpander',
//            'Implementation-Description': $ { appName },
//            'Implementation-License': 'Apache-2.0',
//            'Implementation-License-Url': 'http://www.apache.org/licenses/LICENSE-2.0.html',
//    )
//}

// Generate a jar file - puts results into `rootDir/root/home/release` directory
// This directory structure reflects the server directory structure
jar {

    from {
        configurations.runtimeClasspath.collect { file -> file.isDirectory() ? file : zipTree(file) }
    }
    manifest {

        def manifest = attributes(
                'Implementation-Title': "'${appName}'",
                'Implementation-Version': "'${version}'",
                "Main-Class": mainClassName,
                'Implementation-Vendor': 'com.realityexpander',
                'Implementation-Vendor-Id': 'com.realityexpander',
                'Implementation-Vendor-Url': 'https://github.com/realityexpander',
                'Implementation-Description': "'${ appName }'",
                'Implementation-License': 'Apache-2.0',
                'Implementation-License-Url': 'http://www.apache.org/licenses/LICENSE-2.0.html',
        )
        appManifest = manifest
    }
    destinationDirectory = file("$rootDir/root/home/release")
    archivesBaseName = "app"
}

sourceSets {
    main.kotlin.srcDirs = main.java.srcDirs = ['src']
    test.kotlin.srcDirs = test.java.srcDirs = ['test']
    main.resources.srcDirs = ['resources']
    test.resources.srcDirs = ['testresources']
}

repositories {
    mavenCentral()
    mavenLocal()
    maven { url 'https://kotlin.bintray.com/ktor' }
    maven { url 'https://kotlin.bintray.com/kotlin-js-wrappers' }
    jcenter()

}

// Compiling for JVM 1.8
tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"
    implementation "io.ktor:ktor-server-netty:$ktor_version"
    implementation "ch.qos.logback:logback-classic:$logback_version"
    implementation "io.ktor:ktor-server-core:$ktor_version"
    testImplementation "io.ktor:ktor-server-tests:$ktor_version"

    // HTML and CSS support
    implementation "io.ktor:ktor-html-builder:$ktor_version"
    //implementation "org.jetbrains:kotlin-css-jvm:1.0.0-pre.31-kotlin-1.2.41"
    implementation "org.jetbrains.kotlin-wrappers:kotlin-css:1.0.0-pre.332-kotlin-1.6.21"

    // Auth
    implementation "io.ktor:ktor-auth:$ktor_version"

    // Serialization
    implementation "io.ktor:ktor-gson:$ktor_version"

    // Mongo
    implementation "org.litote.kmongo:kmongo:$kmongo_version"
    implementation "org.litote.kmongo:kmongo-coroutine:$kmongo_version"

    // Coroutines
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:$kotlinx_coroutines_core_version"

    // Encryption / Security
    implementation 'commons-codec:commons-codec:1.14'

    // Network
    implementation "io.ktor:ktor-network-tls:$ktor_version"

    implementation "io.ktor:ktor-freemarker:1.6.8" //$ktor_version"

}


task getAppAttributes {
    dependsOn("jar")

    doLast {
//        println("•--> Get the manifest properties from a file")
//        def manifestFile = "root/home/release/app-${version}.jar.manifest".toString()
//        def manifest = new File(rootDir, manifestFile)
//        def manifestProperties = new Properties()
//        manifest.newInputStream().use {
//            manifestProperties.load(it)
//        }
//        println("•--> Manifest properties:")
//        manifestProperties.each { key, value ->
//            println("•--> " + key + ": " + value)
//        }

        def dontInclude = ['class', 'active', 'properties', 'plugins']
        println appManifest.properties.attributes.each { key, value ->
            if (!dontInclude.contains(key)) {
                println("•--> " + key + ": " + value)
            }
        }
//        println manifest().properties
//        println manifest().effectiveManifest.properties
//                .sort{it.key }
//                .collect{it}
//                .findAll{!dontInclude.contains(it.key)}
//                .join('\n')

//        def include = ['effectiveManifest', 'manifest']
//        println manifest().properties
//                .sort{it.key }
//                .collect{it}
//                .findAll{include.contains(it.key)}
//                .join('\n')
    }
}


task buildAndUploadLatestReleaseWithKeys {
    dependsOn("clean", "jar")  // start with fresh build

    doLast {
        // assumes the SSH keys are in the ~/.ssh directory and
        // that the ~.ssh/config is configured to use the keys for host "hostinger"

        println "•--> Show current tree in the /home directory..."
        runCommand('ssh root@hostinger tree -saD home', 5000)

        println "•--> Remove old files from the /home folder..."
        // runCommand('ssh root@hostinger rm home/release/*.*', 5000) // leave release folder to allow for easy rollbacks
        // runCommand('ssh root@hostinger rm home/release/*', 5000) // needed only for files w/o extensions - left for reference
        runCommand('ssh root@hostinger rm home/*.*', 5000)

        println "•--> Show empty release folder in the /home/release directory..."
        runCommand('ssh root@hostinger tree -saD home', 5000)

        createStartAppScript()

        println "•--> Copy the root/home folder to the server (includes keys and releases, runAppScript)..."
        runCommand('scp -r ./root/home/ hostinger:/root/', 60000)

        println "•--> Show tree with latest files..."
        runCommand('ssh root@hostinger tree -saD home', 5000)

        println "•--> Reload the daemons (just in case)..."
        runCommand('ssh root@hostinger systemctl daemon-reload', 5000)

        println "•--> Restart the server..."
        runCommand('ssh root@hostinger systemctl restart ktornoteapp', 5000)

        println "•--> Getting Server status..."
        runCommand('ssh root@hostinger sleep 3000', 5000)
        runCommand('ssh root@hostinger systemctl status ktornoteapp', 5000)
        runCommand('ssh root@hostinger journalctl -u ktornoteapp | tail -n 10', 5000)

    }
}

def createStartAppScript() {
    println("•--> Create the startApp script for app version: " + version)

    // CANT CREATE FILES USING ECHO COMMAND FROM GRADLE - left for reference
    // def cmd = 'echo "#!/bin/bash /usr/bin/java -jar /home/app-' + version + '.jar" > ./root/home/startApp.sh'
    // def cmd = "echo "hello" > ./root/home/test.txt" // won't create the test.txt file!!!

    def scriptFile = "./root/home/startApp.sh"
    def script = """  // note: this first line is *intentionally* skipped, to conform to normal script format.
            #!/bin/bash
            /usr/bin/java -jar /root/home/release/app-${version.toString()}.jar
            
            # Build-time: ${
                def sdf = new SimpleDateFormat("EEE MM-dd-yyyy HH:mm:ss")
                sdf.setTimeZone(TimeZone.getTimeZone("UTC"))
                sdf.format(new Date()).toString() + " UTC"
            }
            # Application-name: Ktor Note app
            # Application-version: ${version.toString()}
        """
    // # Revision: ${grgit.head().abbreviatedId} // left for reference

    // Trim the script to remove any leading or trailing whitespace and the first line
    def trimmedScript = ""
    script.toString().split("\n").eachWithIndex { line, i ->
        if(i>0) { // skip the first line
            trimmedScript += line.stripIndent().trim() + "\n"
        }
    }.join("\n")
    println("•--> Script: \n" + trimmedScript)

    new File(rootDir, scriptFile).text = trimmedScript

    // Make the script executable
    def cmd = "chmod +x $scriptFile"
    runCommand(cmd, 1000)
}

def runCommand(String cmd, Long timeOut) {
    def sout = new StringBuilder(), serr = new StringBuilder()
    println("Executing: $cmd")

    def proc = cmd.execute()
    proc.consumeProcessOutput(sout, serr)
    proc.waitForOrKill(timeOut)

    println "out> $sout\nerr> $serr"
    proc.destroy()
}







