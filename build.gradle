import java.sql.Time
import java.text.SimpleDateFormat

buildscript {
    repositories {
        mavenCentral()
        //jcenter()
    }
    
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}

apply plugin: 'kotlin'
apply plugin: 'application'

group 'com.realityexpander'
version '0.1.2'
mainClassName = "io.ktor.server.netty.EngineMain"
def appManifest = manifest().effectiveManifest

// Generate a jar file - puts results into `./root/home/release` directory
// This directory structure reflects the server directory structure
jar {
    from {
        configurations.runtimeClasspath.collect { file -> file.isDirectory() ? file : zipTree(file) }
    }
    manifest {
        appManifest = attributes(
                'Implementation-Title': "'${ project.name }'",
                'Implementation-Version': "'${ project.version }'",
                "Main-Class": mainClassName,
                'Implementation-Vendor': 'com.realityexpander',
                'Implementation-Vendor-Id': 'com.realityexpander',
                'Implementation-Vendor-Url': 'https://github.com/realityexpander',
                'Implementation-Description': "'${ project.name }'",
                'Implementation-License': 'Apache-2.0',
                'Implementation-License-Url': 'http://www.apache.org/licenses/LICENSE-2.0.html',
                'SOME-RANDOM-ATTRIBUTE': 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789012345678901234567890'
        )
        appManifest
    }
    destinationDirectory = file("$rootDir/root/home/release")
    archivesBaseName = "app"
}

sourceSets {
    main.kotlin.srcDirs = main.java.srcDirs = ['src']
    test.kotlin.srcDirs = test.java.srcDirs = ['test']
    main.resources.srcDirs = ['resources']
    test.resources.srcDirs = ['testresources']
}

repositories {
    mavenCentral()
    mavenLocal()
    maven { url 'https://kotlin.bintray.com/ktor' }
    maven { url 'https://kotlin.bintray.com/kotlin-js-wrappers' }
    jcenter()

}

// Compiling for JVM 1.8
tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"
    implementation "io.ktor:ktor-server-netty:$ktor_version"
    implementation "ch.qos.logback:logback-classic:$logback_version"
    implementation "io.ktor:ktor-server-core:$ktor_version"
    testImplementation "io.ktor:ktor-server-tests:$ktor_version"

    // HTML and CSS support
    implementation "io.ktor:ktor-html-builder:$ktor_version"
    //implementation "org.jetbrains:kotlin-css-jvm:1.0.0-pre.31-kotlin-1.2.41"
    implementation "org.jetbrains.kotlin-wrappers:kotlin-css:1.0.0-pre.332-kotlin-1.6.21"

    // Auth
    implementation "io.ktor:ktor-auth:$ktor_version"

    // Serialization
    implementation "io.ktor:ktor-gson:$ktor_version"

    // Mongo
    implementation "org.litote.kmongo:kmongo:$kmongo_version"
    implementation "org.litote.kmongo:kmongo-coroutine:$kmongo_version"

    // Coroutines
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:$kotlinx_coroutines_core_version"

    // Encryption / Security
    implementation 'commons-codec:commons-codec:1.14'

    // Network
    implementation "io.ktor:ktor-network-tls:$ktor_version"

    implementation "io.ktor:ktor-freemarker:1.6.8" //$ktor_version"
}


task getAppManifest {
    dependsOn("jar")

    doLast {
        println("•--> Get the manifest properties from the app jar file")
        def manifestFile = "root/home/release/app-${version}.jar".toString()
        def manifestStr = runCommand("unzip -q -c ${manifestFile} META-INF/MANIFEST.MF", 1000, false).toString()
        def manifest = reconstructContinuationLines(manifestStr)

        def manifestProperties = new Properties()
        manifestProperties.load(new StringReader(manifest))

        println("\n•--> Manifest properties:")
        manifestProperties.each { key, value ->
            println(" " + key + ": " + value)
        }

//        // Gets manifest properties from the global variable
//        def dontInclude = ['class', 'active', 'properties', 'plugins']
//        appManifest.properties.attributes.each { key, value ->
//            if (!dontInclude.contains(key)) {
//                println("•--> " + key + ": " + value)
//            }
//        }

        println()

        // Gets manifest properties from the global variable
        println("•--> appManifest: ['Implementation-Version']: " +
                appManifest.properties.attributes['Implementation-Version'])

        // Gets manifest properties from the jar file
        println("•--> manifestProperties: ['Implementation-Version']: " +
                manifestProperties['Implementation-Version'])
    }
}

// JAR/ZIP Manifests have lines limited to 72 characters.
// Lines longer than 72 characters are broken into multiple lines,
//   with a space on the front of the extra lines.
// This function reconstructs continuation lines.
static def String reconstructContinuationLines(String lines) {
    def linesArr = lines.split("\n")
    def manifestRebuilt = ""

    linesArr.each { line ->
        // println("•--> Line: $line")
        if (line.substring(0,1) != ' ') {  // check for continuation line (space at the beginning)
            manifestRebuilt += "\n" + line
        } else {
            manifestRebuilt += line.substring(1)
        }
    }

    return manifestRebuilt
}


task buildAndUploadLatestReleaseWithKeys {
    dependsOn("clean", "jar")  // start with fresh build

    doLast {
        // assumes the SSH keys are in the ~/.ssh directory and
        // that the ~.ssh/config is configured to use the keys for host "hostinger"

        println "•--> Show current tree in the /home directory..."
        runCommand('ssh root@hostinger tree -saD home', 5000)

        println "•--> Remove old files from the /home folder..."
        // runCommand('ssh root@hostinger rm home/release/*.*', 5000) // leave release folder to allow for easy rollbacks
        // runCommand('ssh root@hostinger rm home/release/*', 5000) // needed only for files w/o extensions - left for reference
        runCommand('ssh root@hostinger rm home/*.*', 5000)

        println "•--> Show empty release folder in the /home/release directory..."
        runCommand('ssh root@hostinger tree -saD home', 5000)

        createStartAppScript()

        println "•--> Copy the root/home folder to the server (includes keys and releases, runAppScript)..."
        runCommand('scp -r ./root/home/ hostinger:/root/', 60000)

        println "•--> Show tree with latest files..."
        runCommand('ssh root@hostinger tree -saD home', 5000)

        println "•--> Reload the daemons (just in case)..."
        runCommand('ssh root@hostinger systemctl daemon-reload', 5000)

        println "•--> Restart the server..."
        runCommand('ssh root@hostinger systemctl restart ktornoteapp', 5000)

        println "•--> Getting Server status..."
        runCommand('ssh root@hostinger sleep 3000', 5000)
        runCommand('ssh root@hostinger systemctl status ktornoteapp', 5000)
        runCommand('ssh root@hostinger journalctl -u ktornoteapp | tail -n 10', 5000)
    }

    // Alternative to using bash commands:
    // https://fedidat.com/230-ssh-and-scp-in-gradle/
    // https://stackoverflow.com/questions/25494396/android-gradle-ant-scp-task
    // https://ant.apache.org/manual/Tasks/sshexec.html
    // https://gradle-ssh-plugin.github.io/docs/
    // https://stackoverflow.com/questions/7121637/getting-well-formed-output-from-ant-sshexec-in-groovy-script
}

static void writeFile(String path, String content) {
    def file = new File(path)
    def writer = new FileWriter(file)
    writer.write(content)
    writer.close()
}

def createStartAppScript() {
    println("•--> Create the startApp script for app version: " + version)

    // CANT CREATE FILES USING ECHO COMMAND FROM GRADLE - left for reference
    // Its because the output stream is directed to the console, not the file.
    // def cmd = "echo "hello" > ./root/home/test.txt" // won't create the test.txt file!!!

    def scriptFilePath = "./root/home/startApp.sh"
    def script = """  // note: this first line is *intentionally* skipped, to conform to normal script format.
            #!/bin/bash
            /usr/bin/java -jar /root/home/release/app-${version.toString()}.jar
            
            # Build-time: ${
                def sdf = new SimpleDateFormat("EEE MM-dd-yyyy HH:mm:ss")
                sdf.setTimeZone(TimeZone.getTimeZone("UTC"))
                sdf.format(new Date()).toString() + " UTC"
            }
            # Application-name: ${ project.name }
            # Application-version: ${version.toString()}
        """
    // # Revision: ${grgit.head().abbreviatedId} // left for reference

    // Trim the script to remove any leading or trailing whitespace and the first line
    def trimmedScript = ""
    script.toString().split("\n").eachWithIndex { line, i ->
        if(i>0) { // skip the first line
            trimmedScript += line.stripIndent().trim() + "\n"
        }
    }.join("\n")
    println("•--> Script: \n" + trimmedScript)

    // Save the script file
    new File(rootDir, scriptFilePath).text = trimmedScript

    // Make the script executable
    def cmd = "chmod +x $scriptFilePath"
    runCommand(cmd, 1000)
}

def String runCommand(String cmd, Long timeOut, Boolean printOutput = true) {
    def sout = new StringBuilder(), serr = new StringBuilder()
    println("Executing: $cmd")

    def proc = cmd.execute()
    proc.consumeProcessOutput(sout, serr)
    proc.waitForOrKill(timeOut)

    if (printOutput) println "out> $sout\nerr> $serr"
    proc.destroy()

    return sout.toString()
}







